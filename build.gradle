buildscript {
    ext {
        springBootVersion = '1.2.5.RELEASE'
        spockVersion = '1.0-groovy-2.4'
        groovyVersion = '2.4.4'
        slf4jVersion = '1.7.12'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath("io.spring.gradle:dependency-management-plugin:0.5.2.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'groovy'

apply plugin: 'eclipse'
apply plugin: 'idea'

apply plugin: 'spring-boot'
apply plugin: 'io.spring.dependency-management'


jar {
    baseName = 'hazelcastConfig'
    version = '0.0.1-SNAPSHOT'
}
sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}

configurations.all {
    resolutionStrategy {
        // fail eagerly on version conflict (includes transitive dependencies)
        // e.g. multiple different versions of the same dependency (group and name are equal)
        failOnVersionConflict()
        force("org.slf4j:slf4j-api:$slf4jVersion")
        force('org.hamcrest:hamcrest-core:1.3')
        force('org.glassfish:javax.el:3.0.0')
    }
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    compile("org.springframework.boot:spring-boot-starter-actuator")

    compile('com.hazelcast:hazelcast:3.5.2')

    compile("org.codehaus.groovy:groovy-all:$groovyVersion")

    testCompile("org.spockframework:spock-core:$spockVersion")
    testCompile("org.spockframework:spock-spring:$spockVersion")

    testCompile('cglib:cglib-nodep:2.2')

    testCompile("org.springframework.boot:spring-boot-starter-test")
}


eclipse {
    classpath {
        containers.remove('org.eclipse.jdt.launching.JRE_CONTAINER')
        containers 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.6'
}

//https://stackoverflow.com/questions/31038250/setting-active-profile-and-config-location-from-command-line-in-spring-boot
bootRun {
    String activeProfile = System.properties['spring.profiles.active']
    String confLoc = System.properties['spring.config.location']
    systemProperty "spring.profiles.active", activeProfile
    systemProperty "spring.config.location", "file:$confLoc"
}

test {
    exclude '**/integration/**'
}

task integrationTest(type: Test) {
    include '**/integration/**'
    doFirst {
/*
SERVER_PORT=8100 gradle clean bootRun -Dspring.profiles.active=dev1
SERVER_PORT=8200 gradle clean bootRun -Dspring.profiles.active=dev1
 */
        /*
        TODO: can I replace this with run kicking off spring boot applications twice with different ports?


        SERVER_PORT=8100 gradle clean run
         */
//        println "configuring jetty"
//        jettyServers = setupJettyServers(
//                [
//                        [port: 8100],
//                        [port: 8200]
//                ]
//        )
//        println "starting jetty"
//        jettyServers.each { Server server ->
//            server.start()
//            URI uri = server.getURI()
//            println "started: $uri"
//        }
//        println "started jetty"
    }

//    finalizedBy 'stopJettyServers'
    finalizedBy {

    }
}

/*


task bootRestart << {
    bootStop.execute()
    clean.execute()
    compileJava.execute()
    compileGroovy.execute()
    processResources.execute()
    classes.execute()
    findMainClass.execute()
    bootRun.execute()
}

task bootStop() {
    def port = applicationProperties["server.port"]
    def command = "curl -X POST localhost:$port/shutdown"
    def proc = command.execute()
    proc.waitFor()
}
 */